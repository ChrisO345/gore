package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

var files = []string{
	"vital/assert.go",
	"vital/fluent.go",
	"vital/helpers.go",
}

func main() {
	flag.Parse()
	generate()
}

func generate() {
	for _, file := range files {
		dir, base := filepath.Split(file)
		dir = strings.TrimSuffix(dir, "/")

		switch dir {
		case "vital":
			processVitalFile(base)
		default:
			fmt.Printf("Unknown directory: %s\n", dir)
		}
	}
}

func processVitalFile(filename string) {
	srcPath := filepath.Join("../assert", filename)
	dstPath := filepath.Join("../vital", filename)

	src, err := readFileToBytes(srcPath)
	if err != nil {
		fmt.Printf("Error reading file %s: %v\n", srcPath, err)
		return
	}

	var builder strings.Builder
	builder.WriteString(header)

	lines := strings.SplitSeq(string(src), "\n")
	for line := range lines {
		if strings.HasPrefix(line, "//go:generate") {
			continue
		}
		if strings.HasPrefix(line, "package ") {
			builder.WriteString("package vital\n")
			continue
		}
		// Replace t.Errorf with t.Fatalf
		line = strings.ReplaceAll(line, "t.Errorf", "t.Fatalf")
		builder.WriteString(line + "\n")
	}

	if err := writeBytesToFile(dstPath, []byte(builder.String())); err != nil {
		fmt.Printf("Error writing file %s: %v\n", dstPath, err)
	}
}

const header = `// Code generated by go generate; DO NOT EDIT.

`

func readFileToBytes(path string) ([]byte, error) {
	return os.ReadFile(path)
}

func writeBytesToFile(path string, data []byte) error {
	return os.WriteFile(path, data, 0644)
}
